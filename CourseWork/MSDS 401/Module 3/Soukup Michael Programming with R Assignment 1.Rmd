---
title: 'Soukup_Michael Programming with R Assignment #1'
output:
  html_document: default
---

```{r setup, include = FALSE}
# DO NOT ADD OR REVISE CODE HERE
knitr::opts_chunk$set(echo = TRUE, eval = TRUE)

```

### Test Items starts from here - There are 5 sections - 50 points total ##########################

Read each question carefully and address each element.  Do not output contents of vectors or data frames unless requested.

##### Section 1: (8 points) This problem deals with vector manipulations.

(1)(a)  Create a vector that contains the following, in this order, and output the final, resulting vector.  Do not round any values, unless requested.
* A sequence of integers from 0 to 4, inclusive.
* The number 13
* Three repetitions of the vector c(2, -5.1, -23).
* The arithmetic sum of 7/42, 3 and 35/42

```{r test1a}
v <- c(seq(from = 0, to = 4, by = 1), 13, rep(c(2, -5.1, -23),3), 
       sum(7/42, 3, 35/42))
v
```

(1)(b)  Sort the vector created in (1)(a) in ascending order.  Output this result. Determine the length of the resulting vector and assign to "L". Output L. Generate a descending sequence starting with L and ending with 1. Add this descending sequence arithmetically the sorted vector. This is vector addition, not vector combination. Output the contents. Do not round any values.

```{r test1b}
#Sorted vector v from problem 1a
sort(v,decreasing = FALSE)
#Determine length and assign to L
L <- length(sort(v,decreasing = FALSE))
#Output L
L
#Generate descending sequence from L to 1
L.desc <- seq(from = L, to = 1, by = -1)
#Add descending sequence from L to 1 to the sorted vector. 
v.sum <- L.desc + sort(v,decreasing = FALSE)
v.sum
```

(1)(c) Extract the first and last elements of the vector you have created in (1)(b) to form another vector of the extracted elements. Form a third vector from the elements not extracted. Output these vectors.

```{r test1c}
#Create new vector of first and last elements of vector from 1b. 
v.extract <- c(v.sum[1],v.sum[length(v.sum)])
#Create vector of elements not extracted.
v.third <- c(v.sum[2:(length(v.sum)-1)])
#Output the two vectors created
v.extract
v.third
```

(1)(d) Use the vectors from (c) to reconstruct the vector in (b). Output this vector. Sum the elements and round to two decimal places.

```{r test1d}
#Re-construct vector in b from vectors in c
v.b <- c(v.extract[1],v.third,v.extract[2])
#Output reconstructed vector
v.b
#Sum and round the vector to two decimal places
round(sum(v.b), digits = 2)

#Sum above won't display to hundreths place
#Can force this by text formatting with sprintf
sprintf("%.2f",sum(v.b)) 
```

-----

##### Section 2: (10 points) The expression y = sin(x/2) + cos(x/2) is a trigonometric function.

(2)(a) Create a user-defined function - via *function()* - that implements the trigonometric function above, accepts numeric values, "x," calculates and returns values "y."

```{r test2a}
#Create function as described above
trig.func <- function(x){
  y <- sin(x/2) + cos(x/2)
  return(y)
}
```

(2)(b) Create a vector, x, of 4001 equally-spaced values from -2 to 2, inclusive. Compute values for y using the vector x and your function from (2)(a).  **Do not output x or y.**  Find the value in the vector x that corresponds to the maximum value in the vector y. Restrict attention to only the values of x and y you have computed; i.e. do not interpolate. Round to 3 decimal places and output both the maximum y and corresponding x value.

Finding the two desired values can be accomplished in as few as two lines of code.  Do not use packages or programs you may find on the internet or elsewhere. Do not output the other elements of the vectors x and y. Relevant coding methods are given in the *Quick Start Guide for R*.

```{r test2b}
#Create a vector, x, of 4001 equally-spaced values from -2 to 2, inclusive
x <- seq(from = -2, to = 2, length = 4001)
#Compute values for y using the vector x and function defined in 2a.
y <- trig.func(x)
#Find the value in the vector x that corresponds to the max value in y
location.ymax <- y == max(y)
x.value.ymax <- x[location.ymax] 
#Can also find the ymax location with which.max(y)
loc.ymax <- which.max(y)
x.val.ymax <- x[loc.ymax]
#Concatenate together a clean output of the maximum location
cat("Maximum Y-value: ", round(max(y),digits = 3),"@ X-value: ",round(x.value.ymax, digits = 3))
```

(2)(c) Plot y versus x in color, with x on the horizontal axis. Show the location of the maximum value of y determined in 2(b).  Show the values of x and y corresponding to the maximum value of y in the display. Add a title and other features such as text annotations. Text annotations may be added via *text()* for base R plots and *geom_text()* or *geom_label()* for ggplots.

```{r test2c}
#Plot y vs. x in blue with descriptive title
plot(x,y, type = "p", xlab = "X", ylab ="Y", pch = 16, cex = 0.25, col = "blue",
     main = "Y vs. X for y = sin(x/2) + cos(x/2)", ylim = c(-0.5,1.5))

#Indicate maximum value with separate point on graph in red and larger size
points(x.value.ymax, max(y),pch = 16, cex = 1, col = "red")

#Use text to clearly call out where the maximum value is for this function
text(-1.0, max(y), labels = "Max value occurs at X = 1.571, Y = 1.414",cex = 0.85)

#Add text annotation to show the cartesean coordinates for the max
text(x.value.ymax, max(y)*1.07, labels = sprintf("(%.3f , %.3f)",x.value.ymax, max(y)), 
     cex = 0.7)
```

-----

##### Section 3: (8 points) This problem requires finding the point of intersection of two functions.  Using the function ```y = cos(x/2) * sin(x/2)```, find where the curved line y = -(x/2)^3 intersects it within the range of values used in part (2) (i.e. 4001 equally-spaced values from -2 to 2).  Plot both functions on the same display, and show the point of intersection.  Present the coordinates of this point as text in the display.    

```{r test3}
#Note that the fucntion in Section 3 is different than function in Section 2.

#Re-instiate the x values
x <- seq(from = -2, to = 2, length = 4001)
#Create user-defined functions for two functions called out in this Section.
y <- function(x){
  y <- cos(x/2)*sin(x/2)
  return(y)
}

y1 <- function(x){
  return(-(x/2)^3)
}

#Using range of values form Section two, find the intersection of the two functions
for (i in 1:4001){
  if (abs(y(x[i]) - y1(x[i])) < 0.00001){
    x.equal <- x[i]
    y.equal <- y(x[i])
  }
}

#Alternative approach to check for intersection:
x.intersect <- x[y(x) == y1(x)]
y.intersect <- y(x.intersect)

#Plot the functions

tit.exp <- expression("y = cos(x/2)*sin(x/2) vs. y1 = "-(x/2)^3)

plot(x,y(x), col = 'blue', type = 'l', xlab = "X-value", ylab = "Y-value",
     main = tit.exp)

lines(x,y1(x), col = 'red')

points(x.intersect, y.intersect, col = 'black',pch = 16, cex = 1.0)

text(x.intersect+0.25,y.intersect+0.02,labels = sprintf("(%.1f , %.1f)",x.intersect, y.intersect),
     cex = 0.70)

legend("right",legend = c("y = cos(x/2)*sin(x/2)", expression("y =" -(x/2)^3)),
       col = c("blue","red"), lty = 1:1, cex = 0.75)

```

-----

##### Section 4: (12 points) Use the "trees" dataset for the following items. This dataset has three variables (Girth, Height, Volume) on 31 felled black cherry trees.

(4)(a) Use *data(trees)* to load the dataset. Check and output the structure with *str()*. Use *apply()* to return the median values for the three variables. Output these values.  Using R and logicals, output the row number and the three measurements - Girth, Height and Volume - of any trees with Girth equal to median Girth.  It is possible to accomplish this last request with one line of code.  

```{r test3a}
#Load the trees dataset
data(trees)
#Check and output structure of trees
str(trees)
#Return median values for the columns. 
apply(trees,2,median)
#Output rows and tree measurements for trees with median Girth
trees[(trees$Girth == median(trees$Girth)),]
```

(4)(b) Girth is defined as the diameter of a tree taken at 4 feet 6 inches from the ground. Convert each diameter to a radius, r. Calculate the cross-sectional area of each tree using pi times the squared radius. Present a stem-and-leaf plot of the radii, and a histogram of the radii in color. Plot Area (y-axis) versus Radius (x-axis)  in color showing the individual data points.  Label appropriately.

```{r test3b}
#Girth is diameter, so r is Girth/2, finding radii
r <- trees$Girth/2
#Calculating cross-sectional area
area <- pi*(r^2)
#Calling stem-and-leaf plot of the radii
stem(r)
#Create a histogram of the radii in color
hist(r,col = "darkgreen",right = FALSE, main = "Histogram of Trees radii",
     xlab = "Radius [=] in", ylab = "Frequency")
#Plot Area vs. Radius
plot(r,area,type = "p", col = "darkgreen", pch = 16, xlab = "Radius - in",
     ylab = expression("Area - in"^2), main = "Trees Area vs. Radius")
```

(4)(c) Present a horizontal, notched, colored boxplot of the areas calculated in (b). Title and label the axis.

```{r test3c}
#Create boxplot as described above
boxplot(area, col = "darkolivegreen3", notch = TRUE, main = "Boxplot of Trees Area",
        range = 1.5, horizontal = TRUE, xlab = expression("Area [=] in"^2))
```

(4)(d) Demonstrate that the outlier revealed in the boxplot of Volume is not an extreme outlier.  It is possible to do this with one line of code using *boxplot.stats()* or via 'manual' calculation and logicals. Identify the tree with the largest Volume and output on one line its row number and three measurements.

```{r test3d}
#First, create boxplot of Volume for context
boxplot(trees$Volume, col = "darkolivegreen3", range = 1.5, ylab = "Volume [=] ft^3",
        main = "Boxplot of Trees Volume")

#Identify if the outlier in the boxplot is extreme.
#If the output of this code presents a value(s), then there are extreme outliers
#If the output is numeric(0), this means there are no extreme outliers.
boxplot.stats(trees$Volume, coef = 3.0)$out

#An alternative approach
#IF the calculation below is FALSE, then the outlier is not an extreme outlier
boxplot.stats(trees$Volume)$out > 3.0*(boxplot.stats(trees$Volume)$stats[4] - boxplot.stats(trees$Volume)$stats[2]) + boxplot.stats(trees$Volume)$stats[4]

#Identify tree with largest volume and output its row
trees[trees$Volume == max(trees$Volume),]
```

-----

##### Section 5: (12 points) The exponential distribution is an example of a right-skewed distribution with outliers.  This problem involves comparing it with a normal distribution which typically has very few outliers.  

5(a) Use *set.seed(124)* and *rexp()* with n = 100, rate = 5.5 to generate a random sample designated as y.  Generate a second random sample designated as x with *set.seed(127)* and *rnorm()* using n = 100, mean = 0 and sd = 0.15.  

Generate a new object using *cbind(x, y)*. Do not output this object; instead, assign it to a new name. Pass this object to *apply()* and compute the inter-quartile range (IQR) for each column:  x and y. Use the function *IQR()* for this purpose. Round the results to four decimal places and present (this exercise shows the similarity of the IQR values.).

For information about *rexp()*, use *help(rexp)* or *?rexp()*.  **Do not output x or y.**

```{r test5a}
#set seed 
set.seed(124)
#create random sample from exponential distribution as y
y <- rexp(n = 100, rate = 5.5)

#Create normal random sample as x
set.seed(127)
x <- rnorm(n=100, mean = 0, sd = 0.15)

#Generate new object with cbind
new.obj <- cbind(x,y)

#Calculate IQR for each random sample and round to four decimal places
round(apply(new.obj,2,IQR), digits = 4)
```

(5)(b) This item will illustrate the difference between a right-skewed distribution and a symmetric one.  For base R plots, use *par(mfrow = c(2, 2))* to generate a display with four diagrams; *grid.arrange()* for ggplots. On the first row, for the normal results, present a histogram and a horizontal boxplot for x in color.  For the exponential results, present a histogram and a horizontal boxplot for y in color.

```{r test5b}

#Set up plot space as 2x2 area for four separate plots
par(mfrow = c(2,2))

#Present histogram and horizontal boxplot for random normal vector
hist(x,main = "Random Normal Distribution", col = "turquoise1")
boxplot(x, horizontal = TRUE, main = "Boxplot Random Normal Distribution", col = "turquoise1")

#Present histogram and horizontal boxplot for random exponential vector
hist(y, main = "Random Exponential Distribution", col = "firebrick3")
boxplot(y, horizontal = TRUE, main = "Boxplot Random Exponential Distribution", col = "firebrick3")
```

(5)(c) QQ plots are useful for detecting the presence of heavy-tailed distributions. Present side-by-side QQ plots, one for each sample, using *qqnorm()* and *qqline()*.  Add color and titles. In base R plots, "cex" can be used to control the size of the plotted data points and text. Lastly, determine if there are any extreme outliers in either sample. Remember:  extreme outliers are based on 3.0 x IQR in the box plot. R uses a default value of 1.5 x IQR to define outliers (not extreme) in both boxplot and boxplot stats.

```{r test5c}
#Set up plot space
par(mfrow = c(1,2))

#Plot QQ plots
qqnorm(x, pch = 16,col = "turquoise1", main = "QQ Plot for Normal Sample", cex = 1.5 )
qqline(x)
qqnorm(y, pch = 16, col = "firebrick3", main = "QQ Plot for Exponential Sample", cex = 1.5)
qqline(y)

#Create vector to calculate 3rd Quartile for extreme outlier detection
t <- c(0.75)

if (length(x[x > 3*IQR(x)+quantile(x,t)]) >= 1){
  cat("X has extreme outliers. The value(s) are: ", x[x > 3*IQR(x)+quantile(x,t)])
} else {
  cat("X does not have extreme outliers")
}

if (length(y[y > 3*IQR(y)+quantile(y,t)]) >= 1){
  cat("Y has extreme outliers. The value(s) are: ", y[y > 3*IQR(y)+quantile(y,t)])
} else {
  cat("Y does not have extreme outliers")
}

#Alternative approach, use boxplot.stats with coef = 3 for each vector
#If any values are displayed, this indicates the presence of extreme outliers
#If output is numeric(0), no extreme outliers exist
boxplot.stats(x,coef = 3)$out
boxplot.stats(y,coef = 3)$out
```
